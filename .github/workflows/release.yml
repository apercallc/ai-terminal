name: Release

on:
  push:
    tags:
      - "v*"
  workflow_dispatch:
    inputs:
      tag:
        description: "Release tag to publish (must start with v, e.g. v1.2.3)"
        required: true
        type: string
      allow_unsigned:
        description: "Allow publishing a not-notarized release (NOT recommended)"
        required: false
        default: false
        type: boolean

permissions:
  contents: write

concurrency:
  group: release-${{ github.ref }}
  cancel-in-progress: true

env:
  NODE_VERSION: "20"

jobs:
  verify:
    name: Verify (Node)
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: "npm"

      - name: Install dependencies
        run: npm ci

      - name: ESLint
        run: npm run lint

      - name: TypeScript type check
        run: npm run typecheck

      - name: Prettier check
        run: npx prettier --check "src/**/*.{ts,tsx,css}"

      - name: Run tests
        run: npm test

      - name: Install Playwright browsers
        run: npx playwright install --with-deps chromium

      - name: Run E2E smoke tests
        run: npm run test:e2e

  build_macos:
    name: Build (macOS)
    needs: [verify]
    runs-on: macos-latest
    outputs:
      release_tag: ${{ steps.tag.outputs.release_tag }}
      signing_available: ${{ steps.signing.outputs.available }}
      build_signed_ok: ${{ steps.build_state.outputs.signed_ok }}
      build_unsigned_ok: ${{ steps.build_state.outputs.unsigned_ok }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: "npm"

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable

      - name: Rust cache
        uses: Swatinem/rust-cache@v2
        with:
          workspaces: src-tauri

      - name: Install dependencies
        run: npm ci

      - name: Resolve release tag
        id: tag
        shell: bash
        run: |
          set -euo pipefail

          if [[ "${GITHUB_EVENT_NAME}" == "workflow_dispatch" ]]; then
            TAG="${{ inputs.tag }}"
          else
            TAG="${GITHUB_REF_NAME}"
          fi

          if [[ -z "${TAG}" ]]; then
            echo "ERROR: No release tag provided." >&2
            exit 1
          fi

          if [[ "${TAG}" != v* ]]; then
            echo "ERROR: Release tag must start with 'v' (got: ${TAG})." >&2
            exit 1
          fi

          echo "RELEASE_TAG=${TAG}" >> "$GITHUB_ENV"
          echo "release_tag=${TAG}" >> "$GITHUB_OUTPUT"

      - name: Require signing/notarization for production tags
        if: ${{ github.event_name == 'push' }}
        shell: bash
        run: |
          set -euo pipefail

          missing=()
          [[ -n "${{ secrets.APPLE_CERTIFICATE }}" ]] || missing+=(APPLE_CERTIFICATE)
          [[ -n "${{ secrets.APPLE_CERTIFICATE_PASSWORD }}" ]] || missing+=(APPLE_CERTIFICATE_PASSWORD)
          [[ -n "${{ secrets.APPLE_SIGNING_IDENTITY }}" ]] || missing+=(APPLE_SIGNING_IDENTITY)

          has_apple_id_auth=true
          [[ -n "${{ secrets.APPLE_TEAM_ID }}" ]] || has_apple_id_auth=false
          [[ -n "${{ secrets.APPLE_ID }}" ]] || has_apple_id_auth=false
          [[ -n "${{ secrets.APPLE_PASSWORD }}" ]] || has_apple_id_auth=false

          has_api_key_auth=true
          [[ -n "${{ secrets.APPLE_API_KEY }}" ]] || has_api_key_auth=false
          [[ -n "${{ secrets.APPLE_API_KEY_ID }}" ]] || has_api_key_auth=false
          [[ -n "${{ secrets.APPLE_API_ISSUER }}" ]] || has_api_key_auth=false

          if [[ "$has_apple_id_auth" != "true" && "$has_api_key_auth" != "true" ]]; then
            missing+=(NOTARIZATION_CREDENTIALS)
          fi

          if (( ${#missing[@]} > 0 )); then
            echo "ERROR: Missing required signing/notarization secrets for a production tag release:" >&2
            printf ' - %s\n' "${missing[@]}" >&2
            echo "If you truly need a non-notarized release, run via workflow_dispatch with allow_unsigned=true." >&2
            exit 1
          fi

      - name: Detect signing/notarization availability
        id: signing
        shell: bash
        env:
          APPLE_CERTIFICATE: ${{ secrets.APPLE_CERTIFICATE }}
          APPLE_CERTIFICATE_PASSWORD: ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}
          APPLE_SIGNING_IDENTITY: ${{ secrets.APPLE_SIGNING_IDENTITY }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_PASSWORD: ${{ secrets.APPLE_PASSWORD }}
          APPLE_API_KEY: ${{ secrets.APPLE_API_KEY }}
          APPLE_API_KEY_ID: ${{ secrets.APPLE_API_KEY_ID }}
          APPLE_API_ISSUER: ${{ secrets.APPLE_API_ISSUER }}
        run: |
          set -euo pipefail

          has_signing=true
          [[ -n "${APPLE_CERTIFICATE:-}" ]] || has_signing=false
          [[ -n "${APPLE_CERTIFICATE_PASSWORD:-}" ]] || has_signing=false
          [[ -n "${APPLE_SIGNING_IDENTITY:-}" ]] || has_signing=false

          has_apple_id_auth=true
          [[ -n "${APPLE_TEAM_ID:-}" ]] || has_apple_id_auth=false
          [[ -n "${APPLE_ID:-}" ]] || has_apple_id_auth=false
          [[ -n "${APPLE_PASSWORD:-}" ]] || has_apple_id_auth=false

          has_api_key_auth=true
          [[ -n "${APPLE_API_KEY:-}" ]] || has_api_key_auth=false
          [[ -n "${APPLE_API_KEY_ID:-}" ]] || has_api_key_auth=false
          [[ -n "${APPLE_API_ISSUER:-}" ]] || has_api_key_auth=false

          if [[ "$has_signing" == "true" && ( "$has_apple_id_auth" == "true" || "$has_api_key_auth" == "true" ) ]]; then
            echo "available=true" >> "$GITHUB_OUTPUT"
          else
            echo "available=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Fail fast if signing unavailable and unsigned not allowed
        if: ${{ github.event_name == 'workflow_dispatch' && steps.signing.outputs.available != 'true' && inputs.allow_unsigned != true }}
        shell: bash
        run: |
          echo "ERROR: Apple signing secrets are not configured and 'allow_unsigned' is not enabled." >&2
          echo "Either add the required APPLE_* secrets or re-run with allow_unsigned=true." >&2
          exit 1

      - name: Ensure tag exists (manual dispatch)
        if: ${{ github.event_name == 'workflow_dispatch' }}
        shell: bash
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail

          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"

          git fetch --tags --force

          if git rev-parse "refs/tags/${RELEASE_TAG}" >/dev/null 2>&1; then
            echo "Tag already exists: ${RELEASE_TAG}"
            exit 0
          fi

          echo "Creating tag ${RELEASE_TAG} at ${GITHUB_SHA}"
          git tag "${RELEASE_TAG}" "${GITHUB_SHA}"
          git push origin "refs/tags/${RELEASE_TAG}"

      - name: Generate Tauri icons
        shell: bash
        run: |
          set -euo pipefail
          # Icons are required at compile/package time but are gitignored.
          npx tauri icon src-tauri/icons/icon.svg

      - name: Install Apple signing certificate
        if: ${{ steps.signing.outputs.available == 'true' }}
        shell: bash
        env:
          APPLE_CERTIFICATE: ${{ secrets.APPLE_CERTIFICATE }}
          APPLE_CERTIFICATE_PASSWORD: ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}
        run: |
          set -euo pipefail

          export CERT_PATH="$RUNNER_TEMP/apple_certificate.p12"
          KEYCHAIN_PATH="$RUNNER_TEMP/app-signing.keychain-db"
          KEYCHAIN_PASSWORD="${GITHUB_RUN_ID}-${GITHUB_RUN_ATTEMPT}"

          python3 - <<'PY'
          import base64, os, re
          cert_path = os.environ['CERT_PATH']
          data = os.environ['APPLE_CERTIFICATE']
          data = re.sub(r'\s+', '', data)
          with open(cert_path, 'wb') as f:
            f.write(base64.b64decode(data))
          PY

          security create-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          security set-keychain-settings -lut 21600 "$KEYCHAIN_PATH"
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"

          security default-keychain -s "$KEYCHAIN_PATH"
          security import "$CERT_PATH" -P "$APPLE_CERTIFICATE_PASSWORD" -A -t cert -f pkcs12 -k "$KEYCHAIN_PATH"
          security list-keychains -d user -s "$KEYCHAIN_PATH"
          security set-key-partition-list -S apple-tool:,apple: -s -k "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"

          echo "Available code signing identities:"
          security find-identity -v -p codesigning || true

      - name: Build and sign (without notarization)
        id: tauri_signed
        if: ${{ steps.signing.outputs.available == 'true' }}
        shell: bash
        env:
          APPLE_SIGNING_IDENTITY: ${{ secrets.APPLE_SIGNING_IDENTITY }}
          # Omit APPLE_ID/APPLE_PASSWORD/APPLE_TEAM_ID so Tauri signs but skips notarization
        run: |
          set -euo pipefail
          npx tauri build

      - name: Build (unsigned fallback)
        id: tauri_unsigned
        if: ${{ github.event_name == 'workflow_dispatch' && inputs.allow_unsigned == true && (steps.signing.outputs.available != 'true' || steps.tauri_signed.outcome == 'failure') }}
        shell: bash
        env:
          # If/when enabling Tauri updater signatures
          TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
          TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}
        run: |
          set -euo pipefail

          # Ensure this step never signs/notarizes even if APPLE_* vars
          # exist at the workflow/job/repo level (e.g., GitHub Actions Variables).
          unset APPLE_CERTIFICATE APPLE_CERTIFICATE_PASSWORD APPLE_SIGNING_IDENTITY APPLE_ID APPLE_PASSWORD APPLE_TEAM_ID || true

          npx tauri build

      - name: Build state outputs
        id: build_state
        if: ${{ always() }}
        shell: bash
        run: |
          set -euo pipefail

          signed_ok=false
          unsigned_ok=false

          if [[ "${{ steps.tauri_signed.outcome }}" == "success" ]]; then
            signed_ok=true
          fi

          if [[ "${{ steps.tauri_unsigned.outcome }}" == "success" ]]; then
            unsigned_ok=true
          fi

          echo "signed_ok=${signed_ok}" >> "$GITHUB_OUTPUT"
          echo "unsigned_ok=${unsigned_ok}" >> "$GITHUB_OUTPUT"

      - name: Upload build artifacts (macOS bundle)
        if: ${{ steps.tauri_signed.outcome == 'success' || steps.tauri_unsigned.outcome == 'success' }}
        uses: actions/upload-artifact@v4
        with:
          name: macos-bundle
          if-no-files-found: error
          path: |
            src-tauri/target/release/bundle/macos/*.app
            src-tauri/target/release/bundle/dmg/*.dmg

  notarize_and_release:
    name: Notarize & Release (macOS)
    needs: [build_macos]
    runs-on: macos-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Download build artifacts (macOS bundle)
        uses: actions/download-artifact@v4
        with:
          name: macos-bundle
          path: macos-bundle

      - name: Notarize app with retry
        id: notarize
        if: ${{ needs.build_macos.outputs.signing_available == 'true' && needs.build_macos.outputs.build_signed_ok == 'true' }}
        continue-on-error: ${{ github.event_name == 'workflow_dispatch' && inputs.allow_unsigned == true }}
        shell: bash
        env:
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_PASSWORD: ${{ secrets.APPLE_PASSWORD }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
          APPLE_API_KEY: ${{ secrets.APPLE_API_KEY }}
          APPLE_API_KEY_ID: ${{ secrets.APPLE_API_KEY_ID }}
          APPLE_API_ISSUER: ${{ secrets.APPLE_API_ISSUER }}
          NOTARIZE_ATTEMPTS: ${{ github.event_name == 'push' && 12 || 8 }}
        run: |
          set -euo pipefail

          echo "Environment diagnostics:"
          sw_vers || true
          xcodebuild -version || true
          xcrun notarytool --version || true
          xcrun stapler -h >/dev/null 2>&1 && echo "stapler: ok" || true

          echo "Downloaded artifact contents:" 
          find macos-bundle -maxdepth 6 -print

          APP_PATH=$(find macos-bundle -maxdepth 6 -type d -name '*.app' -print | head -1)
          DMG_PATH=$(find macos-bundle -maxdepth 6 -type f -name '*.dmg' -print | head -1 || true)

          if [[ -z "${APP_PATH:-}" ]]; then
            echo "ERROR: Could not find .app bundle in downloaded artifact." >&2
            exit 1
          fi

          echo "Notarizing: $APP_PATH"

          echo "Preflight signature checks (helps distinguish signing issues from Apple service issues):"
          codesign -dv --verbose=4 "$APP_PATH" 2>&1 || true
          codesign --verify --deep --strict --verbose=2 "$APP_PATH" 2>&1 || true
          spctl -a -vv --type exec "$APP_PATH" 2>&1 || true

          APP_TEAM_ID=$(codesign -dv --verbose=4 "$APP_PATH" 2>&1 | awk -F= '/^TeamIdentifier=/{print $2}' | head -1 || true)
          if [[ -n "${APP_TEAM_ID:-}" ]]; then
            echo "App TeamIdentifier: ${APP_TEAM_ID}"
          fi

          ZIP_PATH="$RUNNER_TEMP/notarize-app.zip"
          # Recommended by Apple for app submission zips
          ditto -c -k --sequesterRsrc --keepParent "$APP_PATH" "$ZIP_PATH"

          AUTH_ARGS=()
          if [[ -n "${APPLE_API_KEY:-}" && -n "${APPLE_API_KEY_ID:-}" && -n "${APPLE_API_ISSUER:-}" ]]; then
            echo "Using App Store Connect API key auth for notarization."
            KEY_PATH="$RUNNER_TEMP/notary-api-key.p8"
            python3 - <<'PY'
            import base64, os, re
            key_path = os.environ['KEY_PATH']
            data = os.environ['APPLE_API_KEY']
            data = re.sub(r'\s+', '', data)
            with open(key_path, 'wb') as f:
              f.write(base64.b64decode(data))
            PY
            AUTH_ARGS+=(--key "$KEY_PATH" --key-id "$APPLE_API_KEY_ID" --issuer "$APPLE_API_ISSUER")
          else
            echo "Using Apple ID auth for notarization."
            if [[ -z "${APPLE_ID:-}" || -z "${APPLE_PASSWORD:-}" || -z "${APPLE_TEAM_ID:-}" ]]; then
              echo "ERROR: Missing Apple ID notarization credentials and no API key provided." >&2
              exit 1
            fi

            if [[ -n "${APP_TEAM_ID:-}" && "${APPLE_TEAM_ID}" != "${APP_TEAM_ID}" ]]; then
              echo "ERROR: APPLE_TEAM_ID (${APPLE_TEAM_ID}) does not match app TeamIdentifier (${APP_TEAM_ID})." >&2
              echo "Fix the secret to match your Developer ID Application certificate team." >&2
              exit 1
            fi

            AUTH_ARGS+=(--apple-id "$APPLE_ID" --password "$APPLE_PASSWORD" --team-id "$APPLE_TEAM_ID")
          fi

          ATTEMPTS="${NOTARIZE_ATTEMPTS:-8}"
          SLEEP_SECONDS=30
          MAX_SLEEP=600

          retryable_regex='(statusCode: Optional\(5[0-9]{2}\)|\b5[0-9]{2}\b|UNEXPECTED_ERROR|server exception|Internal Server Error|Service Unavailable|Gateway Timeout|timed out|Could not connect|network|temporarily unavailable|try again at a later time)'

          for attempt in $(seq 1 "$ATTEMPTS"); do
            echo "=== Notarization attempt ${attempt}/${ATTEMPTS} ==="
            LOG="$RUNNER_TEMP/notarize-${attempt}.log"

            set +e
            xcrun notarytool submit "$ZIP_PATH" \
              "${AUTH_ARGS[@]}" \
              --wait \
              --timeout 25m 2>&1 | tee "$LOG"
            submit_exit=${PIPESTATUS[0]}
            set -e

            if [[ $submit_exit -eq 0 ]]; then
              if grep -qi 'status: Accepted' "$LOG"; then
                echo "Notarization accepted. Stapling..."
                xcrun stapler staple "$APP_PATH"
                if [[ -n "${DMG_PATH:-}" ]]; then
                  echo "Attempting to staple DMG (may lag behind app ticket propagation)..."
                  dmg_stapled=false
                  for s in 1 2 3; do
                    if xcrun stapler staple "$DMG_PATH"; then
                      dmg_stapled=true
                      break
                    fi
                    echo "DMG staple attempt ${s}/3 failed; retrying in 30s..." >&2
                    sleep 30
                  done

                  if [[ "$dmg_stapled" != "true" ]]; then
                    echo "WARNING: DMG stapling failed after retries; continuing (app is stapled)." >&2
                  fi
                fi
                echo "Done."
                exit 0
              fi
            fi

            echo "Notarytool exit code: $submit_exit"
            echo "Notarytool output (last 120 lines):"
            tail -120 "$LOG" || true

            # If the output includes a submission id, surface it for follow-up debugging.
            SUBMISSION_ID=$(grep -Eo '(id:|id =)[[:space:]]*[0-9A-Fa-f-]+' "$LOG" | head -1 | sed -E 's/^(id:|id =)[[:space:]]*//' || true)
            if [[ -n "${SUBMISSION_ID:-}" ]]; then
              echo "Submission id detected: $SUBMISSION_ID"
              xcrun notarytool info "$SUBMISSION_ID" "${AUTH_ARGS[@]}" 2>&1 || true
              xcrun notarytool log "$SUBMISSION_ID" "${AUTH_ARGS[@]}" 2>&1 | tail -200 || true
            fi

            if grep -qEi "$retryable_regex" "$LOG"; then
              echo "Transient Apple error detected."
              if [[ "$attempt" -lt "$ATTEMPTS" ]]; then
                jitter=$((RANDOM % 15))
                sleep_for=$((SLEEP_SECONDS + jitter))
                echo "Retrying in ${sleep_for}s..."
                sleep "$sleep_for"
                SLEEP_SECONDS=$((SLEEP_SECONDS * 2))
                if (( SLEEP_SECONDS > MAX_SLEEP )); then
                  SLEEP_SECONDS=$MAX_SLEEP
                fi
                continue
              fi
              echo "Retries exhausted." >&2
              exit 1
            fi

            echo "Notarization failed with a non-retryable error." >&2
            exit 1
          done

          echo "Retries exhausted." >&2
          exit 1

      - name: Create or update GitHub release (notarized)
        if: ${{ steps.notarize.outcome == 'success' }}
        shell: bash
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail

          RELEASE_TAG="${{ needs.build_macos.outputs.release_tag }}"
          TITLE="AI Terminal ${RELEASE_TAG}"
          NOTES=$(cat <<'EOF'
          See the [CHANGELOG](https://github.com/${{ github.repository }}/blob/main/CHANGELOG.md) for details.
          EOF
          )

          if gh release view "${RELEASE_TAG}" >/dev/null 2>&1; then
            echo "Release already exists: ${RELEASE_TAG}"
          else
            gh release create "${RELEASE_TAG}" --title "$TITLE" --notes "$NOTES" --latest
          fi

      - name: Upload notarized artifacts (DMG)
        if: ${{ steps.notarize.outcome == 'success' }}
        shell: bash
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          RELEASE_TAG="${{ needs.build_macos.outputs.release_tag }}"
          ls -la macos-bundle || true

          mapfile -d '' DMG_FILES < <(find macos-bundle -maxdepth 6 -type f -name '*.dmg' -print0)
          if (( ${#DMG_FILES[@]} == 0 )); then
            echo "ERROR: No .dmg files found in downloaded artifact." >&2
            exit 1
          fi
          gh release upload "${RELEASE_TAG}" "${DMG_FILES[@]}" --clobber

      - name: Create or update GitHub release (not notarized - allowed)
        if: ${{ github.event_name == 'workflow_dispatch' && inputs.allow_unsigned == true && (needs.build_macos.outputs.build_unsigned_ok == 'true' || (needs.build_macos.outputs.signing_available == 'true' && needs.build_macos.outputs.build_signed_ok == 'true')) && steps.notarize.outcome != 'success' }}
        shell: bash
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail

          RELEASE_TAG="${{ needs.build_macos.outputs.release_tag }}"
          TITLE="AI Terminal ${RELEASE_TAG}"
          NOTES=$(cat <<'EOF'
          > **Note:** This build is not notarized. On first launch, right-click the app â†’ Open, then click Open in the dialog. See https://support.apple.com/en-us/102445 for details.

          See the CHANGELOG for details: https://github.com/${{ github.repository }}/blob/main/CHANGELOG.md
          EOF
          )

          if gh release view "${RELEASE_TAG}" >/dev/null 2>&1; then
            gh release edit "${RELEASE_TAG}" --title "$TITLE" --notes "$NOTES" --prerelease
          else
            gh release create "${RELEASE_TAG}" --title "$TITLE" --notes "$NOTES" --latest=false --prerelease
          fi

      - name: Upload non-notarized artifacts (DMG)
        if: ${{ github.event_name == 'workflow_dispatch' && inputs.allow_unsigned == true && (needs.build_macos.outputs.build_unsigned_ok == 'true' || (needs.build_macos.outputs.signing_available == 'true' && needs.build_macos.outputs.build_signed_ok == 'true')) && steps.notarize.outcome != 'success' }}
        shell: bash
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          RELEASE_TAG="${{ needs.build_macos.outputs.release_tag }}"
          ls -la macos-bundle || true

          mapfile -d '' DMG_FILES < <(find macos-bundle -maxdepth 6 -type f -name '*.dmg' -print0)
          if (( ${#DMG_FILES[@]} == 0 )); then
            echo "ERROR: No .dmg files found in downloaded artifact." >&2
            exit 1
          fi
          gh release upload "${RELEASE_TAG}" "${DMG_FILES[@]}" --clobber

      - name: Generate SHA-256 checksums
        if: ${{ steps.notarize.outcome == 'success' || (github.event_name == 'workflow_dispatch' && inputs.allow_unsigned == true && steps.notarize.outcome != 'success') }}
        shell: bash
        run: |
          set -euo pipefail
          OUT="$GITHUB_WORKSPACE/checksums-sha256.txt"
          : > "$OUT"

          # DMGs
          if find macos-bundle -maxdepth 6 -type f -name '*.dmg' -print -quit | grep -q .; then
            find macos-bundle -maxdepth 6 -type f -name '*.dmg' -print0 | sort -z | xargs -0 shasum -a 256 >> "$OUT"
          fi

          # App bundles: hash file contents deterministically
          if find macos-bundle -maxdepth 6 -type d -name '*.app' -print -quit | grep -q .; then
            find macos-bundle -maxdepth 6 -type d -name '*.app' -print0 \
              | xargs -0 -I{} sh -c 'find "$1" -type f -print0' _ {} \
              | sort -z \
              | xargs -0 shasum -a 256 >> "$OUT"
          fi

          echo "\nChecksums written to: $OUT"

      - name: Upload checksums to release
        if: ${{ steps.notarize.outcome == 'success' || (github.event_name == 'workflow_dispatch' && inputs.allow_unsigned == true && steps.notarize.outcome != 'success') }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          RELEASE_TAG="${{ needs.build_macos.outputs.release_tag }}"
          gh release upload "${RELEASE_TAG}" "$GITHUB_WORKSPACE/checksums-sha256.txt" --clobber
